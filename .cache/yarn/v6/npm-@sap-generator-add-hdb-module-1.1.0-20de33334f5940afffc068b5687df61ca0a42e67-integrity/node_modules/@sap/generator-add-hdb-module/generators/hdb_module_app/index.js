'use strict';
const path = require( 'path' );
const Mta = require( '@sap/mta-lib' ).Mta;
const Generator = require( 'yeoman-generator' );
const Utils = require( './Utils' );
const Validation = require( '../Validations' );
const{
    HANA_SERVICE,
    DATABASE_VERSIONS,
    SERVICE_PLAN,
    BIND_LOCAL_PLUGIN_NAME,
    SERVICE_KEY_NAME,
    CREATE_NEW_SERVICE,
    MODULE_TYPE,
    MTA_FILE_PATH_CONF,
    MODULE_NAME_CONF,
    MODULE_PATH_CONF,
    HANA_CLOUD,
    CLOUD_FOUNDRY_PROMPT_DESCRIPTION,
    CLOUD_FOUNDRY_PROMPT_DESCRIPTION_NO_LOGIN,
    CF_CLI_INFO_MESSAGE
} = require( './Constants' );
const fs = require( 'fs' );
class Base extends Generator {
    abortGenerator( error ) {
        if( error.code === 'ENOENT' && error.path === 'mta' ) {
            this.env.error( new Error( 'The mta executable could not be found. Aborting HDB module creation.' ) );
        } else {
            this.env.error( new Error( error.toString() + '. Aborting HDB module creation.' ) );
        }
    }
}

module.exports = class extends Base {
    constructor( args, opts ) {
        super( args, opts );

        this.projectOptions = {
            projectName: null,
            projectPath: null,
            moduleName: null,
            modulePath: null
        };
        this.configPath = opts.baseModuleOptions.configPath;
        this.prompts = opts.baseModuleOptions.prompts;
        this.projectDetails = opts.projectDetails;
        this.generateProject = false;
        this.cfSpaceGuid = null;
        this.cfSpaces = {};
        this.selectedHanaDbInstanceGuid = null;
        this.option( 'babel' );
        this.isCfToolsAvailable = Utils.commandExists( 'cf' );
        this.cloudFoundryPrompt = { name: 'Bind to HDI Container service', description: CLOUD_FOUNDRY_PROMPT_DESCRIPTION };
        let pageHeadingForDatabaseInformation = `Define details of your applicationâ€™s database module.`;
        if( !this.isCfToolsAvailable ){
            pageHeadingForDatabaseInformation = pageHeadingForDatabaseInformation +
                '\n' + CF_CLI_INFO_MESSAGE;
        }
        const prompts = [
            { name: 'Set Database Information', description: pageHeadingForDatabaseInformation },
            this.cloudFoundryPrompt
        ];
        this.parentPromptsQuantity = this.prompts.size();
        this.prompts.splice( this.parentPromptsQuantity, 0, prompts );
        this.featureToggles = new ( require( '@sap/hana-tooling-feature-toggles' ) )( __dirname + '/../../features.json', undefined, opts.vscode );
    }

    _configuring() {
        const mtaConfigOptions = this.fs.readJSON( this.configPath )[
        'generator-base-module'
        ];
        this.projectOptions.projectName = path.basename( path.dirname( mtaConfigOptions[MTA_FILE_PATH_CONF] ) );
        this.projectOptions.projectPath = path.dirname( mtaConfigOptions[MTA_FILE_PATH_CONF] );
        this.projectOptions.moduleName = mtaConfigOptions[MODULE_NAME_CONF];
        this.projectOptions.modulePath = mtaConfigOptions[MODULE_PATH_CONF];
        if( this.projectDetails && this.projectDetails.projectFolder && this.projectDetails.projectName ){
            this.projectOptions.projectPath = this.projectDetails.projectFolder;
            this.projectOptions.projectName = this.projectDetails.projectName;
        }
    }

    async prompting() {
        this._configuring();
        if( !this.isCfToolsAvailable ){
            this.log( CF_CLI_INFO_MESSAGE );
            // remove Bind to HDI Container Service page(aka virtual prompt), if (cf CLI) is not installed on host system
            const indexOfCFPrompt = this.prompts.items.findIndex( item => item.name ===  this.cloudFoundryPrompt.name );
            if( indexOfCFPrompt > -1 ) {
                this.prompts.splice( indexOfCFPrompt, 1 );
            }
        }
        let prompts = null;
        const that = this;
        prompts = [
            {
                type: 'input',
                name: 'namespace',
                message: 'Namespace',
                validate: function( databaseNamespace ) {
                    if( !databaseNamespace ) { return true; }
                    const errorMessage = 'Invalid format for the "Namespace" parameter value: the namespace must start'+
                        ' with a letter and may contain letters, digits, dots, dash and underscores.';
                    return Validation.isValid( databaseNamespace, errorMessage );
                }
            },
            {
                type: 'input',
                name: 'schemaName',
                message: 'Schema Name',
                validate: function( schemaName ) {
                    return Validation.validateSchemaName( schemaName );
                }

            },
            {
                type: 'list',
                name: 'sapHanaDbVersion',
                message: 'SAP HANA Database Version',
                choices: async function() {
                    return that.featureToggles.isFeatureEnabled( 'hana_service' ) ?
                        DATABASE_VERSIONS :
                        [ HANA_CLOUD ];
                },
                'default': 0
            },
            {
                type: 'confirm',
                name: 'createModuleService',
                message: 'Bind the database module to a Cloud Foundry service instance?',
                'default': true,
                validate: async function( answer ){
                    that.cloudFoundryPrompt.description = await Utils.isUserLoggedIn() ?
                        CLOUD_FOUNDRY_PROMPT_DESCRIPTION_NO_LOGIN :
                        CLOUD_FOUNDRY_PROMPT_DESCRIPTION;
                    const indexOfCloudFoundryPrompt = that.prompts.items.findIndex( item => item.name ===  that.cloudFoundryPrompt.name );
                    if( answer === false && indexOfCloudFoundryPrompt > -1 ){
                        that.prompts.splice( indexOfCloudFoundryPrompt, 1 );
                    } else if( answer === true ) {
                        if( indexOfCloudFoundryPrompt === -1 ) {
                            that.prompts.splice( that.prompts.size() + 1, 0, that.cloudFoundryPrompt );
                        } else {
                            // If 'cloudFoundryPrompt' are already included, then remove and re-include
                            // to reflect the description change
                            that.prompts.splice( indexOfCloudFoundryPrompt, 1, that.cloudFoundryPrompt );
                        }
                    }
                    return true;
                },
                guiOptions: {
                    hint: 'Choosing "Yes" will bind the newly created database module to a service instance in the target Cloud Foundry ' +
                        'space. A service instance represents the ' +
                        'deployment target in the database and binding it to the database module is required for deploying the database ' +
                        'module\'s content to the database. You have the option of binding the database module to an existing service instance ' +
                        'or you can choose to create a new service instance.'
                },
                when: () => this.isCfToolsAvailable
            }
        ];

        this.databaseInformation = await this.prompt( prompts );

        if( this.databaseInformation.createModuleService && this.isCfToolsAvailable ){
            await this._handleCfPrompts();
        }
    }

    async _handleCfLoginPrompt(){
        const that = this;
        let cfLoginPrompts = null;
        cfLoginPrompts = [
            {
                type: 'input',
                name: 'apiEndPoint',
                message: 'Enter Cloud Foundry endpoint',
                'default': process.env && process.env.CF_API_ENDPOINT ? process.env.CF_API_ENDPOINT : '',
                validate: async function( apiEndPoint ) {
                    return await Validation.validateCfApiEndPoint( apiEndPoint, that );
                }
            },
            {
                type: 'input',
                name: 'user',
                message: 'Enter e-mail address',
                validate: async function( userId ) {
                    return await Validation.isEmailAddressBlank( userId, that );
                }
            },
            {
                type: 'password',
                name: 'password',
                guiOptions: {
                    type: 'login'
                },
                message: 'Enter Password',
                validate: async function( password ) {
                    return Validation.checkLogin( that.apiEndpoint, that.userId, password );
                }
            }
        ];
        return cfLoginPrompts;
    }
    async _handleCfOrgAndSpacePrompts(){
        const that = this;
        const selectedOrg = await Utils.getSelectedOrg();
        let defaultCfOrgIndex = 0;
        let defaultCfSpaceIndex = 0;
        let cfOrgInfo = null;
        let cfOrgNames = [];
        let cfOrgs = await Utils.getOrgs();
        if( cfOrgs.success ){
            // this.env.error( new Error( 'The generator encountered an error. ' + cfOrgs.errorMessage ) );
            cfOrgInfo = cfOrgs.orgs; //Array of {orgName : orgGuid}
            cfOrgNames = cfOrgInfo.length > 0 ? Object.keys( cfOrgInfo[ 0 ] ) : [];
            if( selectedOrg ){
                defaultCfOrgIndex = cfOrgNames.indexOf( selectedOrg ) >= 0 ?cfOrgNames.indexOf( selectedOrg ) : 0;
            }
        }

        return[
            {
                type: 'list',
                name: 'cfOrg',
                message: 'Choose Cloud Foundry Org',
                guiOptions: {
                    applyDefaultWhenDirty: true
                },
                'default': () => {
                    return defaultCfOrgIndex;
                },
                choices: async function(){
                    if( await Utils.isUserLoggedIn() ){
                        cfOrgInfo = null;
                        cfOrgs = await Utils.getOrgs();
                        if( !cfOrgs.success ){
                            this.env.error( new Error( 'The generator encountered an error. ' + cfOrgs.errorMessage ) );
                        } else {
                            cfOrgInfo = cfOrgs.orgs; //Array of {orgName : orgGuid}
                            cfOrgNames = cfOrgInfo.length > 0 ? Object.keys( cfOrgInfo[ 0 ] ) : [];
                            if( selectedOrg ){
                                defaultCfOrgIndex = cfOrgNames.indexOf( selectedOrg ) >= 0 ?cfOrgNames.indexOf( selectedOrg ) : 0;
                            }
                        }
                        return cfOrgNames;
                    } else {
                        return[];
                    }
                }
            },
            {
                type: 'list',
                name: 'cfSpace',
                message: 'Choose Cloud Foundry Space',
                guiOptions: {
                    applyDefaultWhenDirty: true
                },
                'default': () => {
                    return defaultCfSpaceIndex;
                },
                choices: async function( answers ) {
                    if( await Utils.isUserLoggedIn() ) {

                        if( answers.cfOrg ){
                            const result = await Utils.setOrg( answers.cfOrg );
                            if( result !== true ) {
                                this.env.error( new Error( 'The generator encountered an error while setting the Cloud Foundry org. ' +
                                    'Reason: ' + result ) );
                            }
                        }

                        if( await Utils.getSelectedOrg() ) {
                            that.cfSpaces = await Utils.getSpaces( cfOrgInfo[0][answers.cfOrg] );
                            if( !that.cfSpaces.success ) {
                                this.env.error( new Error( 'The generator encountered an error. ' + that.cfSpaces.errorMessage ) );
                            }
                            return that.cfSpaces.spaces.map( item => Object.keys( item )[0] );
                        } else {
                            return[];
                        }
                    }
                }
            }
        ];
    }
    async _serviceInstanceListPrompt(){
        const that = this;
        that.serviceInstances = {};
        that.hanaCloudDbInstances = {};
        return[
            {
                type: 'confirm',
                name: 'createNewOrBind',
                message: 'Create a new HDI service instance?',
                guiOptions: {
                    applyDefaultWhenDirty: true
                },
                'default': async( answers ) => {
                    if( answers.cfSpace ) {
                        const result = await Utils.setSpace( answers.cfSpace );
                        if( result !== true ) {
                            this.env.error( new Error( 'The generator encountered an error while setting the Cloud Foundry space. ' +
                                'Reason: ' + result ) );
                        }
                    }
                    return true;
                }
            },
            {
                when: answers => {
                    return answers.createNewOrBind === true;
                },
                type: 'input',
                name: 'newServiceInstanceName',
                message: 'Please enter a unique and non-existing service instance name',
                'default': Utils.computeServiceInstanceName( that.projectOptions.projectName, that.projectOptions.moduleName ),
                validate: async function( serviceInstanceName ) {
                    return Validation.validateServiceInstanceName( serviceInstanceName, Object.keys( that.serviceInstances ) );
                }
            },
            {
                type: 'confirm',
                name: 'useDefaultDatabase',
                message: 'Use the default database instance of the selected Cloud Foundry space?',
                'default': true,
                when: answers => answers.createNewOrBind === true
            },
            {
                type: 'list',
                name: 'cfHanaDbInstance',
                message: 'Choose a target SAP HANA database instance',
                'default': 0,
                choices: async() => {
                    await that._findSelectedSpaceGuid();
                    if( that.cfSpaceGuid ){
                        try {
                            const result = await Utils.getHanaCloudDatabasesList( that.cfSpaceGuid, that.databaseInformation.sapHanaDbVersion );
                            if( !result.success ) {
                                that.env.error( new Error( 'The generator encountered an error. ' + result.errorMessage ) );
                            }
                            Object.assign( that.hanaCloudDbInstances, result.hanaCloudServiceInstances );
                            return Object.keys( result.hanaCloudServiceInstances );
                        } catch( e ) {
                            that.env.error( new Error( 'The generator encountered an error. ' + e.message ) );
                        }

                    } else {
                        return[];
                    }
                },
                when: ( answers ) => {
                    return answers && answers.createNewOrBind === true && answers.useDefaultDatabase === false;
                }
            },
            {
                type: 'list',
                name: 'selectedInstanceName',
                message: 'Choose Cloud Foundry Service',
                guiOptions: {
                    applyDefaultWhenDirty: true
                },
                'default': () => {
                    return 0;
                },
                when: ( answers ) => {
                    return answers.createNewOrBind === false;
                },
                choices: async function() {
                    if( await Utils.isUserLoggedIn() ) {
                        await that._findSelectedSpaceGuid();
                        if( that.cfSpaceGuid ) {
                            try {
                                const result = await Utils.getServiceInstanceList( that.cfSpaceGuid, that.databaseInformation.sapHanaDbVersion );
                                if( !result.success ) {
                                    that.env.error( new Error( 'The generator encountered an error. ' + result.errorMessage ) );
                                }
                                Object.assign( that.serviceInstances, result.serviceInstances );
                                return Object.keys( result.serviceInstances );
                            } catch( e ) {
                                that.env.error( new Error( 'The generator encountered an error. ' + e.message ) );
                            }

                        } else {
                            return[];
                        }
                    }
                }
            }
        ];
    }

    async _handleCfPrompts(){
        let cfPrompts = [];
        const isLoggedIn = await Utils.isUserLoggedIn();
        if( !isLoggedIn ){
            cfPrompts = await this._handleCfLoginPrompt();
            cfPrompts =  cfPrompts.concat(  await this._handleCfOrgAndSpacePrompts() );
        } else {
            const selectedOrg = await Utils.getSelectedOrg();
            const selectedSpace = await Utils.getSelectedSpace();
            if( !selectedOrg || !selectedSpace ){
                cfPrompts =  await this._handleCfOrgAndSpacePrompts();
            }
        }
        cfPrompts.push( ... await this._serviceInstanceListPrompt() );
        this.cfInformation = await this.prompt( cfPrompts );
    }

    async _findSelectedSpaceGuid() {
        const that = this;
        if( Object.keys( that.cfSpaces ).length === 0 ) {
            const selectedOrg = await Utils.getSelectedOrg();
            let selectedOrgGuid = null;
            let cfOrgInfo = null;
            let cfOrgs = await Utils.getOrgs();
            if( cfOrgs.success ) {
                cfOrgInfo = cfOrgs.orgs; //Array of {orgName : orgGuid}
                cfOrgInfo.some( item => {
                    if( item[selectedOrg] ) {
                        selectedOrgGuid = item[selectedOrg];
                        return true;
                    }
                });
            }
            that.cfSpaces = await Utils.getSpaces( selectedOrgGuid );
        }

        let selectedSpace = await Utils.getSelectedSpace();
        if( selectedSpace && Array.isArray( that.cfSpaces.spaces ) ){
            that.cfSpaces.spaces.some( ( item ) => {
                if( item[ selectedSpace ] ){
                    that.cfSpaceGuid = item[ selectedSpace ];
                    return true;
                }
            });
        }
    }

    async _updateMtaModules() {
        let that = this;
        let mtaHdbhdbModule = {
            name: that.projectOptions.moduleName,
            type: MODULE_TYPE,
            path: that.projectOptions.modulePath,
            requires: [
                {
                    name: 'hdi_'+that.projectOptions.moduleName
                }
            ]
        };
        if( this.projectDetails && this.projectDetails.projectName ){
            const mtaModuleRequires =  mtaHdbhdbModule.requires;
            mtaModuleRequires[0][ 'properties' ] = { 'TARGET_CONTAINER': '~{hdi-container-name}' };
        }
        await this.mta.addModule( mtaHdbhdbModule );
    }

    async _updateMtaResources() {
        let that = this;
        let mtaHdbModuleResource = {
            name: 'hdi_'+that.projectOptions.moduleName,
            properties: {
                'hdi-container-name': '${service-name}'
            },
            type: 'com.sap.xs.hdi-container'
        };
        if( that.databaseInformation.schemaName ) {
            mtaHdbModuleResource.parameters = {
                config: {
                    schema: that.databaseInformation.schemaName
                }
            };
        }
        if( this.selectedHanaDbInstanceGuid ){
            if( mtaHdbModuleResource.parameters && mtaHdbModuleResource.parameters.config ){
                mtaHdbModuleResource.parameters.config['database_id'] = this.selectedHanaDbInstanceGuid;
            } else {
                mtaHdbModuleResource.parameters = {
                    config: {
                        database_id: this.selectedHanaDbInstanceGuid
                    }
                };
            }
        }

        await this.mta.addResource( mtaHdbModuleResource );
    }

    _checkForHanaCloudDbInstanceGuid(){
        if( this.cfInformation && this.cfInformation.cfHanaDbInstance && Object.keys( this.hanaCloudDbInstances ).length > 0 ) {
            const hanaCloudDbInstanceGuid = this.hanaCloudDbInstances[ this.cfInformation.cfHanaDbInstance ];
            if( hanaCloudDbInstanceGuid ){
                this.selectedHanaDbInstanceGuid = hanaCloudDbInstanceGuid;
            }
        }
    }
    async _updateMtaFile() {
        try {
            await this._updateMtaModules();
            await this._updateMtaResources();
            await this.mta.save();
        } catch( e ) {
            this.abortGenerator( e );
        }
    }

    async _createServiceKey( instanceName ){
        try {
            this.log( `Creating the service key "${SERVICE_KEY_NAME}" for the Cloud Foundry service instance "${instanceName}"` );
            const config = { permissions: [ 'development' ] };
            await Utils.createServiceKey( instanceName, SERVICE_KEY_NAME, config );
            this.log( `The service key "${SERVICE_KEY_NAME}" has been created successfully` );
        } catch( e ) {
            this.log( 'An error occurred while creating the service key: ' + e.toString() );
            return e;
        }
    }

    async _createService() {
        const projectName = this.projectOptions.projectName;
        this.instanceName = this.cfInformation.newServiceInstanceName;
        const schemaName = Utils.computeSchemaName( this.databaseInformation.schemaName, this.projectOptions.moduleName, projectName );
        const config = { schema: schemaName, makeUniqueName: true };
        if( this.selectedHanaDbInstanceGuid ){
            config.database_id = this.selectedHanaDbInstanceGuid;
        }
        try {
            this.log( `Creating the Cloud Foundry service instance "${this.instanceName}"` );
            const hanaTrial = 'hanatrial';
            let serviceType = ( this.databaseInformation.sapHanaDbVersion === HANA_SERVICE &&
                await Utils.isServiceAvailableInCfSpace( hanaTrial, this.cfSpaceGuid ) )
                ? hanaTrial
                : 'hana';
            await Utils.createService( serviceType, SERVICE_PLAN, this.instanceName, JSON.stringify( config ) );
            this.log( `The Cloud Foundry service instance "${this.instanceName}" has been created successfully` );
        } catch( e ) {
            this.log( 'An error occurred while creating the service: ' + e.toString() );
            return e;
        }
        return await this._createServiceKey( this.instanceName );
    }

    async _localBindService( instanceName ){
        if( await Utils.isPluginAvailable( BIND_LOCAL_PLUGIN_NAME ) ){
            try {
                this.log( `Binding the Cloud Foundry service instance "${instanceName}" to the generated database module` );
                await Utils.bindService(
                    path.join( this.projectOptions.projectPath, this.projectOptions.modulePath ),
                    instanceName,
                    'hdi_' + this.projectOptions.moduleName );
                this.log( `The Cloud Foundry service instance "${instanceName}" has been bound to the generated database module successfully` );
            } catch( e ) {
                return e;
            }
        } else {
            this.log( 'Unable to bind the Cloud Foundry service instance to the generated database module, because the Cloud Foundry CLI plugin ' +
                '"bind-local" is not available.' );
        }
        return undefined;
    }

    async _installPackageDependencies() {
        try {

            process.chdir( path.join( this.projectOptions.projectPath, this.projectOptions.modulePath ) );
            this.installDependencies({
                bower: false,
                npm: true,
                yarn: false
            });
        } catch( e ) {
            this.log( 'An error occurred while building the module: ' + e.toString() + '\nPlease run "npm install" in the module directory.' );
            return e;
        }

        return undefined;
    }

    async writing() {
        this.generateProject = !fs.existsSync( this.projectDetails.projectFolder );
        if( this.projectDetails && this.projectDetails.projectFolder && this.projectDetails.tmpProjectFolderPath ){
            if( this.generateProject ){
                fs.mkdirSync( this.projectDetails.projectFolder );
            }
            fs.copyFileSync( path.join( this.projectDetails.tmpProjectFolderPath, 'mta.yaml' ),
                             path.join( this.projectDetails.projectFolder, 'mta.yaml' )
            );
            if( this.featureToggles.isFeatureEnabled( 'bas_project_gitignore' ) ) {
                fs.copyFileSync( path.join( __dirname, 'templates', 'project_gitignore' ),
                                 path.join( this.projectDetails.projectFolder, '.gitignore' )
                );
            }
        }
        try {
            this.mta = new Mta( this.projectOptions.projectPath );
        } catch( e ) {
            this.abortGenerator( e );
        }
        this._checkForHanaCloudDbInstanceGuid();
        await this._updateMtaFile();

        const props = {
            namespace: this.databaseInformation.namespace
        };
        const modulePath = path.join( this.projectOptions.projectPath, this.projectOptions.modulePath );
        if( this.databaseInformation.namespace ){
            this.fs.copyTpl(
                this.templatePath( path.join( 'project_name', 'db', 'src', 'hdinamespace' ) ),
                path.join( modulePath, 'src', '.hdinamespace' ),
                props
            );
        }

        this.fs.copy(
            this.templatePath( path.join( 'hdiconfig', this.databaseInformation.sapHanaDbVersion.replace( /\s+/g, '_' ).toLowerCase() ) ),
            path.join( modulePath, 'src', '.hdiconfig' )
        );
        this.fs.copy(
            this.templatePath( path.join( 'project_name', 'db', '_package.json' ) ),
            path.join( modulePath, 'package.json' )
        );

        this.fs.copy(
            this.templatePath( 'gitignore' ),
            path.join( modulePath, '.gitignore' )
        );
    }

    async _createNewServiceInstanceAndBind( errors ){
        if( await Utils.getSelectedOrg() && await Utils.getSelectedSpace() ){
            let e = await this._createService();
            if( e ) {
                errors.push( e );
            } else {
                const err = await this._localBindService( this.instanceName );
                if( err ){
                    errors.push( err );
                }
            }
        } else {
            errors.push( new Error( 'Cloud Foundry Org and Space are not set.' ) );
        }
        return errors;
    }

    async _bindSelectedService( errors ){
        let error = null;
        const serviceInstanceGuid = this.serviceInstances[ this.cfInformation.selectedInstanceName ];
        try {
            if( !await Utils.isSharedDevKeyAvailable( serviceInstanceGuid ) ){
                error = await this._createServiceKey( this.cfInformation.selectedInstanceName );
                if( error ){
                    errors.push( error );
                }
            }
            error = await this._localBindService( this.cfInformation.selectedInstanceName );
            if( error ){
                errors.push( error );
            }
        } catch( err ){
            errors.push( new Error( 'An error occurred while binding the service: ' + err.toString() ) );
        }
        return errors;
    }

    async install(){
        if( this.log.showProgress && typeof this.log.showProgress === 'function' ){
            const postfix = this.generateProject ? 'Project' : 'Module';
            this.log.showProgress( 'Generating SAP HANA Database ' + postfix );
        }
        let errors = [];
        if( this.databaseInformation.createModuleService && this.cfInformation && this.cfInformation.newServiceInstanceName ){
            errors = await this._createNewServiceInstanceAndBind( errors );
        } else {
            if( this.databaseInformation.createModuleService && this.cfInformation && this.cfInformation.selectedInstanceName &&
                this.cfInformation.selectedInstanceName !== CREATE_NEW_SERVICE
            ){
                errors = await this._bindSelectedService( errors );
            }
        }

        let e = await this._installPackageDependencies();
        if( e ) {
            errors.push( e );
        }

        this._displayErrors( errors );
    }
    _displayErrors( errors ){
        if( errors.length > 0 ) {
            if( errors.length === 1 ) {
                this.env.error( new Error( 'The generator encountered an error: ' + errors[0].toString() ) );
            } else {
                let message = 'The generator encountered ' + errors.length + ' errors: [';
                for( let i = 0; i < errors.length; i++ ) {
                    if( i > 0 ) {
                        message += ',';
                    }
                    message += '"' + errors[i].toString() + '"';
                }
                message += ']';
                this.env.error( new Error( message ) );
            }
        }
    }
};
