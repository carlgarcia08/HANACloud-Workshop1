'use strict';
const path = require( 'path' );
const fs = require( 'fs' );
const cfTools = require( '@sap/cf-tools' );
const commandExistsSync = require( 'command-exists' ).sync;
const{ v4: uuidv4 } = require( 'uuid' );
const md5 = require( 'md5' );
const{ SERVICE_KEY_NAME, SERVICE_HANA_TRIAL, SERVICE_HANA, HANA_CLOUD, HDI_SHARED, DATABASE_VERSIONS } = require( './Constants' );
const FeatureToggles = new ( require( '@sap/hana-tooling-feature-toggles' ) )( __dirname + '/../../features.json' );
class Utils {
    //checks is user is logged-in to Cloud Foundry
    static async isUserLoggedIn() {
        const cliResult = await cfTools.Cli.execute( [ 'oauth-token' ] );
        return cliResult.exitCode === 0 && !cliResult.error && !cliResult.stderr;
    }

    static async initiateLogin( apiEndPoint, userName, password ){
        const cliResult = await cfTools.Cli.execute( [ 'login', '-a', apiEndPoint, '-u', userName, '-p', password ] );
        return cliResult.exitCode === 0;
    }

    // checks if a service is available in CF dev space
    static async isServiceAvailableInCfSpace( serviceName, cfSpaceGuid ) {
        if( !cfSpaceGuid ) {
            throw new Error( 'dev space guid must not be a falsy value' );
        }
        if( !serviceName ) {
            throw new Error( 'Service name must not be a falsy value' );
        }
        const cliResult = await cfTools.Cli.execute( [ 'curl', `/v2/spaces/${cfSpaceGuid}/services?q=label%3A${serviceName}` ] );
        if( cliResult.exitCode !==0 ){
            throw new Error( cliResult.stderr || cliResult.stdout );
        } else {
            try {
                const parsedJson = JSON.parse( cliResult.stdout );
                return parsedJson.total_results > 0;
            } catch( e ) {
                throw new Error( 'Could not parse the API response for checking Cloud Foundry Service.' );
            }
        }
    }

    // returns path of cf config.json file
    static getCfConfigFilePath(){
        const cfConfigRelativePath = path.join( '.cf', 'config.json' );
        if( process.env && process.env.CF_HOME && fs.existsSync( path.join( process.env.CF_HOME, cfConfigRelativePath ) ) ){
            return path.join( process.env.CF_HOME, cfConfigRelativePath );
        } else if( process.env && process.env.HOME && fs.existsSync( path.join( process.env.HOME, cfConfigRelativePath ) ) ){
            return path.join( process.env.HOME, cfConfigRelativePath );
        }
        return undefined;
    }

    //returns Cloud Foundry Org(user selected)
    static async getSelectedOrg(){
        try {
            const cfConfig = JSON.parse( fs.readFileSync( Utils.getCfConfigFilePath(), 'utf8' ) );
            return cfConfig.OrganizationFields && cfConfig.OrganizationFields.Name ?
                cfConfig.OrganizationFields.Name
                : '';
        } catch( e ) {
            return undefined;
        }
    }

    //returns Cloud Foundry Space(user selected)
    static async getSelectedSpace(){
        try {
            const cfConfig = JSON.parse( fs.readFileSync( Utils.getCfConfigFilePath(), 'utf8' ) );
            return cfConfig && cfConfig.SpaceFields && cfConfig.SpaceFields.Name ?
                cfConfig.SpaceFields.Name
                : '';
        } catch( e ) {
            return undefined;
        }
    }

    // list of Org from Cloud foundry
    static async getOrgs(){
        const cliResult = await cfTools.Cli.execute( [ 'curl', '/v2/organizations?order-by=name' ] );
        let orgs = [];
        let success = false;
        let errorMessage = '';
        if( cliResult.exitCode === 0 ){
            try {
                const obj = {};
                const orgResponse = JSON.parse( cliResult.stdout );
                if( orgResponse && orgResponse.resources && Array.isArray( orgResponse.resources ) ){
                    orgResponse.resources.forEach( item => {
                        const orgName = item.entity && item.entity.name
                            ? item.entity.name: null;
                        const orgGuid = item.metadata && item.metadata.guid
                            ? item.metadata.guid: null;
                        if( orgName && orgGuid ){
                            obj[orgName] = orgGuid;
                        }
                    });
                    if( Object.keys( obj ).length > 0 ) {
                        orgs.push( obj );
                    }
                    success = true;
                } else {
                    errorMessage = 'No Cloud Foundry Orgs found.';
                    success = true;
                }
            } catch( e ) {
                errorMessage = 'Could not parse the API response for Cloud Foundry Orgs.';
                return{ success: false, orgs: [ ], errorMessage };
            }
        } else {
            errorMessage = 'Failed to fetch Cloud Foundry Orgs, Reason: ' + ( cliResult.stderr || cliResult.stdout );
        }
        return{ success, orgs, errorMessage };
    }

    // list of Spaces for the already selected Org from Cloud foundry
    static async getSpaces( orgGuid ){
        let spaces = [];
        let success = false;
        let errorMessage = '';
        if( orgGuid && typeof orgGuid === 'string' ){
            const cliResult = await cfTools.Cli.execute( [ 'curl', `/v2/spaces?order-by=name&q=organization_guid:${orgGuid}` ] );
            if( cliResult.exitCode === 0 ){
                try {
                    const spaceResponse = JSON.parse( cliResult.stdout );
                    if( spaceResponse && spaceResponse.resources && Array.isArray( spaceResponse.resources ) ){

                        spaceResponse.resources.forEach( item => {
                            const spaceName = item.entity && item.entity.name && item.metadata && item.metadata.guid
                                ? item.entity.name: null;
                            if( spaceName ){
                                let obj = {};
                                obj[spaceName] = item.metadata.guid;
                                spaces.push( obj );
                            } else {
                                console.log( 'space name and/or space guid not found' );
                            }
                        });
                        success = true;
                    } else {
                        errorMessage = 'No Cloud Foundry Spaces found.';
                        success = true;
                    }
                } catch( e ) {
                    errorMessage = 'Could not parse the API response for Cloud Foundry Spaces.';
                    return{ success: false, spaces, errorMessage };
                }
            } else {
                errorMessage = 'Failed to fetch Cloud Foundry Spaces, Reason: ' + ( cliResult.stderr || cliResult.stdout );
            }
        }
        return{ success, spaces, errorMessage };
    }

    // change Org
    static async setOrg( cfOrg ) {
        const cliResult = await cfTools.Cli.execute( [ 'target', '-o', cfOrg ] );
        return cliResult.exitCode === 0 ? true : cliResult.stderr;
    }

    // change space
    static async setSpace( cfSpace ) {
        const cliResult = await cfTools.Cli.execute( [ 'target', '-s', cfSpace ] );
        return cliResult.exitCode === 0 ? true : cliResult.stderr;
    }

    static async bindService( hdbModulePath, serviceName, resourceName ){
        if( !path.isAbsolute( hdbModulePath ) ) {
            // eslint-disable-next-line max-len
            throw new Error( 'Failed to bind the generated service to the project, Reason: the module path (' + hdbModulePath + ') must be an absolute path.' );
        }
        const dotenvPath = path.join( hdbModulePath, '.env' );
        const cliResult = await cfTools.Cli.execute( [
            'bind-local',
            '-path',
            dotenvPath,
            '-service-names',
            serviceName,
            '-tags',
            'mta-resource-name:' + resourceName,
            '-service-keys',
            SERVICE_KEY_NAME
        ] );
        if( cliResult.exitCode !== 0 ){
            throw new Error( 'Failed to bind generated service to the project, Reason: ' + ( cliResult.stderr || cliResult.stdout ) );
        }
        fs.chmodSync( dotenvPath, 0o600 );
    }

    static async isPluginAvailable( pluginName ){
        let isAvailable = false;
        if( pluginName ) {
            const cliResult = await cfTools.Cli.execute( [ 'plugins' ] );
            if( cliResult.exitCode === 0 ){
                let outputLines = cliResult.stdout.split( '\n' );
                outputLines.splice( 0, 3 );
                outputLines.splice( -3, 3 );
                isAvailable = outputLines.some( line => {
                    const lineTokens = line.split( /\s\s+/g );
                    return lineTokens[2] === pluginName;
                });
            }
        }
        return isAvailable;
    }

    static async createServiceKey( serviceName, key, config ) {
        const command = [ 'create-service-key', serviceName, key ];
        if( config ) {
            if( typeof config !== 'object' ) {
                throw new Error( 'Config must be an object, but found ' + ( typeof config ) );
            }
            command.push( '-c' );
            command.push( JSON.stringify( config ) );
        }
        console.log( 'Creating the "' + key + '" service key for the "' + serviceName + '" service...' );
        let cliResult = await cfTools.Cli.execute( command );
        if( cliResult.exitCode !== 0 ) {
            throw new Error( 'Failed to create "' + key + '" service key for '
                    + serviceName + ' service, Reason: ' + cliResult.stderr );
        }
    }
    static async createService( serviceType, servicePlan, instanceName, config ) {
        console.log( 'Creating the "' + instanceName + '" service...' );
        let cliResult = await cfTools.apiCreateServiceInstance( serviceType, servicePlan, instanceName, config );
        if( cliResult.exitCode !== 0 ) {
            throw new Error( 'Failed to create the service "' + instanceName + '"; Reason: '
                    + cliResult.stderr );
        }
        console.log( 'Verifying that the service is created ...' );
        await this._verifyCreatedService( instanceName );
    }
    static async _verifyCreatedService( instanceName ) {
        let properties = {};
        do{
            let cliResult = await cfTools.Cli.execute( [ 'service', instanceName ] );
            if( cliResult.exitCode !== 0 ) {
                throw new Error( 'Failed to verify that the service "' + instanceName + '" has been created; Reason: '
                        + cliResult.stderr );
            }
            let lines = cliResult.stdout.split( '\n' );
            properties = this._loadProperties( lines );
            if( properties.status === 'create succeeded' ) {
                console.log( 'The "' + instanceName + '" service has been created successfully' );
                return;
            } else if( properties.status !== 'create in progress' ) {
                throw new Error( 'Failed to create the "' + instanceName + '" service; Status: ' + properties.status );
            }
        } while( properties.status !== 'create succeeded' );
    }
    static _loadProperties( lines ) {
        let properties = {};
        lines.forEach( ( line ) => {
            let pos = line.indexOf( ':' );
            if( pos !== -1 ) {
                let key = line.substring( 0, pos );
                let value = '';
                if( pos + 1 < line.length ) {
                    value = line.substring( pos + 1 ).trim();
                }
                properties[key] = value;
            }
        });
        return properties;
    }

    static async isSharedDevKeyAvailable( serviceInstanceGuid ){
        if( !serviceInstanceGuid || typeof serviceInstanceGuid !== 'string' ) {
            throw new Error( `Service Instance guid format error. expected: string(length > 0) found: ${typeof serviceInstanceGuid}` );
        }
        const cliResult = await cfTools.cfGetServiceKeys(
            {
                'filters': [
                    {
                        'key': cfTools.eFilters.service_instance_guid,
                        'value': serviceInstanceGuid
                    }
                ]
            }
        );
        if( cliResult && Array.isArray( cliResult ) ) {
            return cliResult.some( item => {
                return item.entity && item.entity.name && item.entity.name === SERVICE_KEY_NAME;
            });
        } else {
            console.log( `received output not in expected format. Expected: Array, Found: ${cliResult}` );
        }
        return false;
    }

    static _doesServiceParametersMatch( item, servicePlan, serviceType ) {
        if( item && typeof item === 'object' && Object.keys( item ).length > 0 ){
            const serviceTypeCheck = item.service_plan && item.service_plan.service && item.service_plan.service.label &&
                item.service_plan.service.label === serviceType;
            const servicePlanCheck = item.service_plan && item.service_plan.name && item.service_plan.name === servicePlan;
            return servicePlan ? serviceTypeCheck && servicePlanCheck : serviceTypeCheck;
        }
        return false;
    }
    static _parseServicesFromTrialLandscape( item, dbVersion ) {
        if( dbVersion === HANA_CLOUD ) {
            const hanaServiceLabelCheck = Utils._doesServiceParametersMatch( item, HDI_SHARED, SERVICE_HANA );
            return hanaServiceLabelCheck ? item.name || null : null;
        } else {
            const hanaTrialServiceLabelCheck = Utils._doesServiceParametersMatch( item, HDI_SHARED, SERVICE_HANA_TRIAL );
            return hanaTrialServiceLabelCheck ? item.name || null : null;
        }
    }

    static _parseServicesFromNonTrialLandscape( item, servicePlan, serviceType ) {
        const hanaServiceLabelCheck = Utils._doesServiceParametersMatch( item, servicePlan, serviceType );
        return hanaServiceLabelCheck ? item.name || null : null;
    }

    static _parseServiceByTypeAndPlan( item, servicePlan, serviceType ) {
        const serviceTypeAndNameCheck = Utils._doesServiceParametersMatch( item, servicePlan, serviceType );
        return serviceTypeAndNameCheck ? item.name || null : null;
    }

    /**
     *
     * @param cfSpaceGuid
     * @param dbVersion
     * @returns {Promise<{success: boolean, errorMessage: string, serviceInstances: {}}>}
     * @description : This method returns a list of SAP HANA service instances appropriate for the SAP Cloud Platform region
     */
    static async getServiceInstanceList( cfSpaceGuid, dbVersion ) {
        let serviceInstances = {};
        let success = false;
        let errorMessage = '';
        if( !cfSpaceGuid || typeof cfSpaceGuid !== 'string' ){
            throw new Error( `Cloud Foundry Space guid format error. expected: string(length > 0) found: ${typeof cfSpaceGuid}` );
        }
        const upsServiceResult = await Utils.getUserProvidedServiceInstances( cfSpaceGuid );
        if( upsServiceResult.success === true ) {
            serviceInstances = Object.assign({}, upsServiceResult.upsInstances );
        } else {
            return{ success: false, serviceInstances: serviceInstances, errorMessage: upsServiceResult.error };
        }
        const isHanaTrialServiceAvailable = await Utils.isServiceAvailableInCfSpace( SERVICE_HANA_TRIAL, cfSpaceGuid );
        const cliResult = await cfTools.Cli.execute( [ 'curl', `/v2/spaces/${cfSpaceGuid}/summary` ] );
        if( cliResult.exitCode === 0 ){
            try {
                const result = JSON.parse( cliResult.stdout );
                if( result && result.services && Array.isArray( result.services ) ){
                    if( result.services.length === 0 ){
                        console.log( 'No CF services found.' );
                        errorMessage = 'No CF services found.';
                    } else {
                        result.services.forEach( item => {

                            let serviceName = null;
                            if( isHanaTrialServiceAvailable ){
                                serviceName = Utils._parseServicesFromTrialLandscape( item, dbVersion );
                            } else {
                                serviceName = Utils._parseServiceByTypeAndPlan( item, HDI_SHARED, SERVICE_HANA );
                            }

                            if( serviceName ){
                                serviceInstances[ serviceName ] = item.guid;
                            }
                        });
                    }
                    success = true;
                } else {
                    const message = 'output is not in the expected format. Expected Array<services>, found: ';
                    errorMessage = result && result.services ?
                        `${message}${result.services}`:
                        `${message}undefined`
                    ;
                }
            } catch( e ) {
                errorMessage = 'Could not parse the API response for the Cloud Foundry services list.';
                return{ success: false, serviceInstances: {}, errorMessage };
            }
        } else {
            serviceInstances = {};
            errorMessage = 'Failed to fetch Cloud Foundry Services, Reason: ' + ( cliResult.stderr || cliResult.stdout );
        }
        return{ success, serviceInstances: serviceInstances, errorMessage };
    }

    static async getHanaCloudDatabasesList( cfSpaceGuid, dbVersion = HANA_CLOUD ) {
        if( !DATABASE_VERSIONS.includes( dbVersion ) ){
            throw new Error( 'Failed to fetch Cloud Foundry Services, Reason: Unknown Database version.' );
        }
        let hanaCloudServiceInstances = {};
        let success = false;
        let errorMessage = '';
        if( !cfSpaceGuid || typeof cfSpaceGuid !== 'string' ){
            throw new Error( `Cloud Foundry Space guid format error. expected: string(length > 0) found: ${typeof cfSpaceGuid}` );
        }
        const serviceType = dbVersion === HANA_CLOUD || !FeatureToggles.isFeatureEnabled( 'hana_service' ) ? 'hana-cloud': 'hana-db';
        const servicePlan = dbVersion === HANA_CLOUD || !FeatureToggles.isFeatureEnabled( 'hana_service' ) ? 'hana': null;
        const cliResult = await cfTools.Cli.execute( [ 'curl', `/v2/spaces/${cfSpaceGuid}/summary` ] );
        if( cliResult.exitCode === 0 ){
            try {
                const result = JSON.parse( cliResult.stdout );
                if( result && result.services && Array.isArray( result.services ) ){
                    if( result.services.length === 0 ){
                        console.log( `No "SAP HANA Cloud" service instances found.` );
                        errorMessage = `No "SAP HANA Cloud" service instances found.`;
                    } else {
                        result.services.forEach( item => {

                            let serviceName = Utils._parseServiceByTypeAndPlan( item, servicePlan, serviceType );
                            if( serviceName ){
                                hanaCloudServiceInstances[ serviceName ] = item.guid;
                            }
                        });
                    }
                    success = true;
                } else {
                    const message = 'output is not in the expected format. Expected Array<services>, found: ';
                    errorMessage = result && result.services ?
                        `${message}${result.services}`:
                        `${message}undefined`
                    ;
                }
            } catch( e ) {
                errorMessage = 'Could not parse the API response for the Cloud Foundry services list.';
                return{ success: false, hanaCloudServiceInstances: {}, errorMessage };
            }
        } else {
            hanaCloudServiceInstances = {};
            errorMessage = 'Failed to fetch Cloud Foundry Services, Reason: ' + ( cliResult.stderr || cliResult.stdout );
        }
        return{ success, hanaCloudServiceInstances: hanaCloudServiceInstances, errorMessage };
    }

    static async getUserProvidedServiceInstances( cfSpaceGuid ){
        const upsInstances = {};
        let success = false;
        let error = '';
        let cliResult = await cfTools.Cli.execute( [ 'curl', `/v2/user_provided_service_instances?q=space_guid%3A${cfSpaceGuid}` ] );
        if( cliResult.exitCode === 0 ) {
            let result = null;
            try {
                result = JSON.parse( cliResult.stdout );

                if( result && result.total_results === 0 ) {
                    console.log( 'No Cloud Foundry user-provided services found.' );
                    success = true;
                } else {
                    if( result && result.resources && Array.isArray( result.resources ) ){
                        const resources = result.resources;
                        resources.forEach( resource => {
                            let serviceName = null;
                            const serviceTags = resource.entity && resource.entity.credentials &&
                            resource.entity.credentials.tags ? resource.entity.credentials.tags: [];
                            if( Array.isArray( serviceTags ) ){
                                serviceTags.some( tag => {
                                    if( tag && typeof tag === 'string' && tag.toLowerCase() === 'hana' ) {
                                        serviceName = resource.entity && resource.entity.name ? resource.entity.name : null;
                                        return true;
                                    }
                                });
                            } else if( typeof serviceTags === 'string' ){
                                serviceName = resource.entity && resource.entity.name && serviceTags.toLowerCase() === 'hana' ?
                                    resource.entity.name :
                                    null;
                            }


                            if( resource.metadata && resource.metadata.guid && serviceName ){
                                upsInstances[ serviceName ] = resource.metadata.guid;
                            }
                        });
                        success = true;
                    } else {
                        error =  'output is not in the expected format.';
                    }
                }
            } catch( e ) {
                error = 'Could not parse the API response for Cloud Foundry user-provided services list.';
            } finally{
                result = null;
                cliResult = null;
            }
        } else {
            error = 'Error occurred while fetching user provided list. Reason: ' + cliResult.stderr || cliResult.stdout;
            cliResult = null;
        }
        return{ upsInstances, error, success };
    }

    static commandExists( commandName ){
        return commandExistsSync( commandName );
    }

    static computeSchemaName( schemaName, moduleName, projectName ){
        if( !schemaName ){
            schemaName = `${projectName}_hdi_${moduleName}`;
        }
        /**
         * Schema name length limit is 64, if it exceeds 64 then take first 48 characters as it is and append 12 randomly
         * generated hash. This shall leave the room for HANA to adjust the name for uniqueName
         */
        if( schemaName.length > 64 ){
            schemaName = schemaName.substr( 0, 48 ) +
                Buffer.from( md5( schemaName ), 'hex' ).toString( 'base64' ).substr( 0, 12 );
        }
        // schema name validation: valid characters are "A"-"Z", "0"-"9", and "_", and the first character cannot be "_"
        schemaName = schemaName.replace( /[^A-Z0-9]+/ig, '_' );
        return schemaName.charAt( 0 ) === '_' ? schemaName.substr( 1  ) : schemaName;
    }

    static computeServiceInstanceName( projectName, moduleName ){
        /*
            A unique name<projectName + moduleName + suffix> is required to create the service.
            If environment variable is set for workspace id, then use it as suffix.(Should be available in Appstudio)
            else use  UUID as suffix
         */
        let workspaceId = null;
        const workSpacePrefix = 'workspaces-';
        workspaceId = process && process.env && process.env.WORKSPACE_ID;
        if( workspaceId && workspaceId.startsWith( workSpacePrefix ) ){
            workspaceId = workspaceId.replace( workSpacePrefix, '' );
        }
        let suffix = workspaceId;
        if( !suffix ) {
            const buffer = Buffer.alloc( 16 );
            uuidv4( null, buffer, 0 );
            suffix = buffer.toString( 'base64' ).substr( 0, 22 );
        }
        let instanceName = `${projectName}-hdi${moduleName}-${suffix}`;
        // Service Names are limited to 50 characters.
        if( instanceName.length > 50 ){
            instanceName = instanceName.substr( 0, 28 ) +
                Buffer.from( md5( instanceName ), 'hex' ).toString( 'base64' ).substr( 0, 22 );
        }
        //Validation: https://docs.cloudfoundry.org/devguide/services/managing-services.html#create
        //generated instance might have characters that are not allowed.
        instanceName = instanceName.replace( /[^A-Z0-9_-]+/ig, '' );
        return instanceName;
    }
}
module.exports = Utils;
