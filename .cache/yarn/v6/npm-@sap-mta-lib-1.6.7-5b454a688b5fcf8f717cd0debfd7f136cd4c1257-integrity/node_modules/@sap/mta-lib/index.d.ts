/**
 * The Mta class contains operations that can be performed on mta.yaml files,
 * like creating, reading and modifying them.
 *
 * The operations are made on-disk, meaning that different instances of this class
 * which reference the same folder work on the same data. Concurrent modifications
 * are prevented by using a hash on the file which is updated during each operation,
 * so every modification operation must be preceded by a read (or other modification) operation.
 *
 * It uses a temporary file in the modification operations to enable a way to
 * rollback changes. The modified data is copied back to the original mta.yaml
 * file when `save` is called.
 */
export declare class Mta {
  /**
   * The path to the directory that holds the mta.yaml
   */
  readonly mtaDirPath: string;
  /**
   * Create a new `Mta` instance.
   * @param mtaDirPath - The directory of the mta.yaml file
   * @param useTempFile - Should changes be performed on a temporary file. True by default. Use the save() method
   * to update the mta.yaml file.
   * @param mtaExtFilePaths - A list of Multi target Application (МТА) extension descriptor files. Empty by default.
   */
  constructor(
    mtaDirPath: string,
    useTempFile?: boolean,
    mtaExtFilePaths?: string[]
  );
  /**
   * Creates a new temporary mta.yaml file (or mta.yaml file, if useTempFile is false) with the descriptor.
   */
  create(descriptor: mta.MtaDescriptor): Promise<void>;
  /**
   * Gets the MTA file path. If the MTA file path doesn't exist, an error message is thrown.
   */
  getMtaFilePath(includeTemp?: boolean): Promise<string>;
  /**
   * Gets the MTA ID.
   */
  getMtaID(): Promise<string>;
  /**
   *  Validate the mta.yaml and the defined the mta ext files.
   */
  validate(): Promise<Record<string, mta.Issue[]>>;
  /**
   *  Adds a new resource.
   */
  addModule(module: mta.Module, force?: boolean): Promise<void>;
  /**
   *  Adds a new resource.
   */
  addResource(resource: mta.Resource, force?: boolean): Promise<void>;
  /**
   *  Gets all modules.
   */
  getModules(): Promise<mta.Module[]>;
  /**
   * Gets all resources.
   */
  getResources(): Promise<mta.Resource[]>;
  /**
   * Get the resource configuration (service creation parameters).
   */
  getResourceConfig(resourceName: string): Promise<Record<string, unknown>>;
  /**
   * Updates an existing module.
   */
  updateModule(module: mta.Module): Promise<void>;
  /**
   * Updates an existing resource.
   */
  updateResource(resource: mta.Resource): Promise<void>;
  /**
   * Updates the build parameters.
   * Updates the existing build parameters or adds new build parameters if they don't exist.
   */
  updateBuildParameters(
    buildParameters: mta.ProjectBuildParameters,
    force?: boolean
  ): Promise<void>;
  /**
   * Checks if the name given exists in the "mta.yaml" file.
   * @param name
   */
  doesNameExist(name: string): Promise<boolean>;
  /**
   * Saves the "mta.yaml" file:
   * Copies the "temp.mta.yaml" file content to the "mta.yaml" file.
   * Deletes the "temp.mta.yaml" file.
   */
  save(): Promise<void>;
  /**
   * Deletes the temporary mta file.
   */
  clean(): Promise<void>;
  /**
   * Resolve mta module properties.
   */
  resolveModuleProperties(
    moduleName: string,
    envFile?: string
  ): Promise<{
    properties: Record<string, string>;
    messages: string[];
  }>;
}

export default Mta;

/**
 * The mta namespace contains the types used in mta.yaml files
 */
export namespace mta {
  // Created according to MTA schema version 3.2
  // (https://github.com/cloudfoundry-incubator/multiapps/tree/master/spec/schemas/v3/v3.2)
  export interface MtaDescriptor {
    "_schema-version": string;
    ID: string;
    description?: string;
    version: string;
    provider?: string;
    copyright?: string;
    modules?: Module[];
    "module-types"?: ModuleType[];
    resources?: Resource[];
    "resource-types"?: ResourceType[];
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
    "build-parameters"?: ProjectBuildParameters;
    includes?: Includes[];
  }

  export interface Module {
    name: string;
    type: string;
    description?: string;
    path?: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    includes?: Includes[];
    requires?: Requires[];
    provides?: Provides[];
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
    "build-parameters"?: {
      [index: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
    };
    "deployed-after"?: string[];
  }

  export interface ModuleType {
    name: string;
    extends: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
  }

  export interface Resource {
    name: string;
    type?: string;
    description?: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
    includes?: Includes[];
    optional?: boolean;
    active?: boolean;
    requires?: ResourceRequires[];
  }

  export interface ResourceType {
    name: string;
    extends: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
  }

  export interface Parameters {
    [index: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  }

  export interface ParametersMetadata {
    overwritable?: boolean;
    optional?: boolean;
  }

  export interface ProjectBuildParameters {
    "before-all"?: BuildParameters[];
    "after-all"?: BuildParameters[];
  }

  export interface BuildParameters {
    builder?: string;
    timeout?: string;
    commands?: string[];
  }

  export interface Includes {
    name: string;
    path: string;
  }

  export interface Properties {
    [index: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any
  }

  export interface PropertiesMetadata {
    overwritable?: boolean;
    optional?: boolean;
    datatype?: "str" | "int" | "float" | "bool";
  }

  export interface Provides {
    name: string;
    public?: boolean;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
  }

  export interface Requires {
    name: string;
    group?: string;
    list?: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
    includes?: Includes[];
  }

  export interface ResourceRequires {
    name: string;
    properties?: Properties;
    "properties-metadata"?: PropertiesMetadata;
    parameters?: Parameters;
    "parameters-metadata"?: ParametersMetadata;
    includes?: Includes[];
  }

  export interface Issue {
    severity: "warning" | "error";
    message: string;
    line: number;
    column: number;
  }
}

/**
 * Check if the Cloud MTA executable is available in the path, and if it is at least
 * the minimal required version.
 * In case it is not, an error is thrown.
 */
export function ensureCloudMtaInstalled(): Promise<void>;

/**
 * Check if the error thrown by ensureCloudMtaInstalled happened because the Cloud MTA executable is not available.
 * If false, the error could be because of a version mismatch.
 */
export function isCloudMtaNotInstalledError(err: Error): boolean;

/**
 * The minimal required Cloud MTA version.
 * If the available version of Cloud MTA is lower than this version, some features
 * may not work.
 */
export declare const MIN_CLOUD_MTA_VERSION: string;
