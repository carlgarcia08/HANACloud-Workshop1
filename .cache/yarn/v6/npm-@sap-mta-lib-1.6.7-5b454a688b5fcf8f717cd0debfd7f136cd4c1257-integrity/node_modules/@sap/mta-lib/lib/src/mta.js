"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mta = exports.MTA_NOT_FOUND_MESSAGE = void 0;
const crypto_1 = require("crypto");
const path_1 = require("path");
const tempDir = require("temp-dir");
const process_utils_1 = require("./process-utils");
const fs_extra_1 = require("fs-extra");
const tempFileName = "temp.mta.yaml";
const mtaFileName = "mta.yaml";
exports.MTA_NOT_FOUND_MESSAGE = "Multi-target application not found";
function parseOutput(output) {
    try {
        return JSON.parse(output);
    }
    catch (e) {
        /* istanbul ignore next */
        throw new Error(`Not a valid JSON output: ${output}\n${e.message}`);
    }
}
class Mta {
    constructor(mtaDirPath, useTempFile = true, mtaExtFilePaths = []) {
        this.mtaDirPath = mtaDirPath;
        this.mtaExtFilePaths = mtaExtFilePaths;
        if (useTempFile) {
            const hash = crypto_1.createHash("md5").update(this.mtaDirPath).digest("hex");
            this.mtaTempFilePath = path_1.join(tempDir, hash + "." + tempFileName);
        }
        this.mtaFilePath = path_1.join(this.mtaDirPath, mtaFileName);
    }
    /**
     * Creates a new temporary mta.yaml file (or mta.yaml file, if useTempFile is false) with the descriptor.
     */
    async create(descriptor) {
        var _a;
        await this.clean();
        const output = await process_utils_1.runMta([
            "create",
            "-p",
            (_a = this.mtaTempFilePath) !== null && _a !== void 0 ? _a : this.mtaFilePath,
            "-d",
            JSON.stringify(descriptor),
        ]);
        this.hashcode = parseOutput(output).hashcode;
    }
    /**
     * Gets the MTA file path. If the MTA file path doesn't exist, an error message is thrown.
     */
    async getMtaFilePath(includeTemp = true) {
        if (this.mtaTempFilePath !== undefined &&
            includeTemp &&
            (await fs_extra_1.pathExists(this.mtaTempFilePath))) {
            return this.mtaTempFilePath;
        }
        else if (await fs_extra_1.pathExists(this.mtaFilePath)) {
            return this.mtaFilePath;
        }
        throw new Error(exports.MTA_NOT_FOUND_MESSAGE);
    }
    /**
     * Gets the MTA ID.
     */
    async getMtaID() {
        return await this.runOnExistingFile(["get", "id"]);
    }
    /**
     *  Adds a new module.
     */
    async addModule(module, force = false) {
        const args = ["add", "module", "-d", JSON.stringify(module)];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    /**
     *  Adds a new resource.
     */
    async addResource(resource, force = false) {
        const args = ["add", "resource", "-d", JSON.stringify(resource)];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    addMtaExtFlagsToCommandArgs(command) {
        const flagsAndMtaExtFilePaths = [];
        this.mtaExtFilePaths.forEach((mtaExtFilePath) => flagsAndMtaExtFilePaths.push("-x", mtaExtFilePath));
        return command.concat(flagsAndMtaExtFilePaths);
    }
    /**
     *  validate the mta.yaml and the defined the mta ext files.
     */
    async validate() {
        const getModulesCommand = this.addMtaExtFlagsToCommandArgs(["validate"]);
        return await this.runOnExistingFile(getModulesCommand);
    }
    /**
     *  Gets all modules.
     */
    async getModules() {
        const getModulesCommand = this.addMtaExtFlagsToCommandArgs([
            "get",
            "modules",
        ]);
        return await this.runOnExistingFile(getModulesCommand);
    }
    /**
     * Gets all resources
     */
    async getResources() {
        const getResourceCommand = this.addMtaExtFlagsToCommandArgs([
            "get",
            "resources",
        ]);
        return await this.runOnExistingFile(getResourceCommand);
    }
    async getResourceConfig(resourceName) {
        let getResourceConfigCommand = [
            "get",
            "resource-config",
            "-r",
            resourceName,
            "-w",
            this.mtaDirPath,
        ];
        getResourceConfigCommand = this.addMtaExtFlagsToCommandArgs(getResourceConfigCommand);
        return await this.runOnExistingFile(getResourceConfigCommand);
    }
    /**
     * Updates an existing module.
     */
    async updateModule(module) {
        await this.runOnTempFile([
            "update",
            "module",
            "-d",
            JSON.stringify(module),
        ]);
    }
    /**
     * Updates an existing resource.
     */
    async updateResource(resource) {
        await this.runOnTempFile([
            "update",
            "resource",
            "-d",
            JSON.stringify(resource),
        ]);
    }
    /**
     * Updates the build parameters.
     * Updates the existing build parameters or adds new build parameters if they don't exist.
     */
    async updateBuildParameters(buildParameters, force = false) {
        const args = [
            "update",
            "buildParameters",
            "-d",
            JSON.stringify(buildParameters),
        ];
        if (force) {
            args.push("-f");
        }
        await this.runOnTempFile(args);
    }
    /**
     * Checks if the name given exists in the "mta.yaml" file.
     * @param name
     */
    async doesNameExist(name) {
        return await this.runOnExistingFile(["exist", "-n", name]);
    }
    /**
     * Saves the "mta.yaml" file:
     * Copies the "temp.mta.yaml" file content to the "mta.yaml" file.
     * Deletes the "temp.mta.yaml" file.
     */
    async save() {
        if (this.mtaTempFilePath !== undefined &&
            (await fs_extra_1.pathExists(this.mtaTempFilePath))) {
            const output = await process_utils_1.runMta([
                "copy",
                "-s",
                this.mtaTempFilePath,
                "-t",
                this.mtaFilePath,
            ]);
            await process_utils_1.runMta(["deleteFile", "-p", this.mtaTempFilePath]);
            this.hashcode = parseOutput(output).hashcode;
        }
    }
    /**
     * Deletes the temporary mta file.
     */
    async clean() {
        if (this.mtaTempFilePath !== undefined &&
            (await fs_extra_1.pathExists(this.mtaTempFilePath))) {
            await process_utils_1.runMta(["deleteFile", "-p", this.mtaTempFilePath]);
        }
    }
    /**
     * Resolve mta module.
     */
    async resolveModuleProperties(moduleName, envFile) {
        let args = [
            "resolve",
            "-m",
            moduleName,
            "-o",
            "json",
            "-w",
            this.mtaDirPath,
        ];
        if (envFile !== undefined) {
            args = args.concat(["-e", envFile]);
        }
        args = this.addMtaExtFlagsToCommandArgs(args);
        return this.runOnExistingFile(args);
    }
    /**
     * Runs the MTA command with the sent arguments and the additional argument `-p <temp file path>`.
     * Before running the MTA command, the function makes sure that the "temp.mta.yaml" exists
     * according to the following logic:
     * If the "temp.mta.yaml" file exists, runs the MTA command on it.
     * If the "temp.mta.yaml" file doesn't exist, checks if the "mta.yaml" file exists;
     * if not, displays an error message.
     * If the "mta.yaml" file exists, copies the "mta.yaml" file content to the "temp.mta.yaml" file
     * and then runs the MTA command on it.
     *
     * @param args - the arguments to send to the MTA executable.
     */
    async runOnTempFile(args) {
        var _a;
        let filePath;
        // When this.mtaTempFilePath is undefined we work on this.mtaFilePath directly
        if (this.mtaTempFilePath === undefined) {
            filePath = this.mtaFilePath;
            if (!(await fs_extra_1.pathExists(this.mtaFilePath))) {
                throw new Error(exports.MTA_NOT_FOUND_MESSAGE);
            }
        }
        else {
            filePath = this.mtaTempFilePath;
            // Create the temp file if it doesn't exist
            if (!(await fs_extra_1.pathExists(this.mtaTempFilePath))) {
                if (!(await fs_extra_1.pathExists(this.mtaFilePath))) {
                    throw new Error(exports.MTA_NOT_FOUND_MESSAGE);
                }
                const output = await process_utils_1.runMta([
                    "copy",
                    "-s",
                    this.mtaFilePath,
                    "-t",
                    this.mtaTempFilePath,
                ]);
                this.hashcode = parseOutput(output).hashcode;
            }
        }
        args = args.concat(["-p", filePath, "-c", (_a = this.hashcode) !== null && _a !== void 0 ? _a : "0"]);
        const output = await process_utils_1.runMta(args);
        const outputObj = parseOutput(output);
        this.hashcode = outputObj.hashcode;
        return outputObj.result;
    }
    async runOnExistingFile(args) {
        args = args.concat(["-p", await this.getMtaFilePath()]);
        const output = await process_utils_1.runMta(args);
        const outputObj = parseOutput(output);
        this.hashcode = outputObj.hashcode;
        return outputObj.result;
    }
}
exports.Mta = Mta;
//# sourceMappingURL=mta.js.map