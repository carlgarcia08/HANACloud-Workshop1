"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupPromptsSteps = exports.validateModuleName = exports.validateTargetFolderPath = exports.validateMtaPath = void 0;
const chalk_1 = require("chalk");
const fs = require("fs");
const path = require("path");
const mta_lib_1 = require("@sap/mta-lib");
const messages_1 = require("./messages");
exports.validateMtaPath = async (mtaFilePath) => {
    // validate input is not empty
    if (!mtaFilePath) {
        return chalk_1.default.red(messages_1.messages.MTA_PATH_VALIDATION_ERR);
    }
    // validate mta.yaml file exists (in case, user mentioned file other than mta.yaml, or non existing file)
    const mtaFolderPath = path.dirname(mtaFilePath);
    const mtaInstance = new mta_lib_1.default(mtaFolderPath);
    try {
        const filePath = await mtaInstance.getMtaFilePath(false);
        if (filePath === mtaFilePath) {
            return true;
        }
        return chalk_1.default.red(messages_1.messages.MTA_PATH_VALIDATION_ERR);
    }
    catch (error) {
        return chalk_1.default.red(messages_1.messages.MTA_PATH_VALIDATION_ERR);
    }
};
exports.validateTargetFolderPath = (folderPath) => {
    // validate input is not empty
    if (!folderPath) {
        return chalk_1.default.red(messages_1.messages.TARGET_FOLDER_PATH_VALIDATION_ERR);
    }
    // validate folder exists
    const result = fs.existsSync(folderPath);
    if (result) {
        return true;
    }
    return chalk_1.default.red(messages_1.messages.TARGET_FOLDER_PATH_VALIDATION_ERR);
};
exports.validateModuleName = async (name, mtaFolderPath, targetFolderPath, defModuleName) => {
    // validate input is not empty
    if (!name) {
        return chalk_1.default.red(messages_1.messages.EMPTY_MODULE_NAME_VALIDATION_ERR);
    }
    // validate name matches the allowed pattern
    const re = /^[a-zA-Z_][a-zA-Z0-9_\-.]*(?<![.])$/;
    const result = re.test(name);
    if (!result) {
        return chalk_1.default.red(messages_1.messages.MODULE_NAME_VALIDATION_ERR);
    }
    // user accepted the default proposed, no need to validate module and folder existence, as it is done before
    if (name === defModuleName) {
        return true;
    }
    // validate module name is not in  mta.yaml already
    const mtaInstance = new mta_lib_1.default(mtaFolderPath);
    const moduleExists = await mtaInstance.doesNameExist(name);
    if (moduleExists) {
        return chalk_1.default.red(messages_1.messages.MODULE_NAME_EXISTS_ERR);
    }
    // validate module folder name is not in target folder already
    if (!targetFolderPath) {
        return true;
    }
    const folderExists = fs.existsSync(path.join(targetFolderPath, name));
    if (folderExists) {
        return chalk_1.default.red(messages_1.messages.MODULE_FOLDER_EXISTS_ERR);
    }
    return true;
};
exports.setupPromptsSteps = (parentPrompts, parentPromptsQuantity) => {
    // every prompt added is correspondent to this.prompt call in the generator
    const prompts = [
        { name: messages_1.messages.GENERAL_STEP, description: "" }
    ];
    parentPrompts.splice(parentPromptsQuantity, 0, prompts);
};
//# sourceMappingURL=promptValidator.js.map